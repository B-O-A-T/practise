1.栈排序 
2.链表实现队列 
3.最长连续递增序列 
4.最长不连续序列 
5.二维数组回行打印 
6.无序数组构建一棵二叉排序树 
7.一个数组实现两个栈 
8.二叉树宽度 
9.二叉树是否对称 
10.链表m到n反转 
11.一个n位数，现在可以删除其中任意k位，使得剩下的数最小 
12.实现有符号大数链表加法，靠近头结点位置为高位 
13.字符串横向改纵向 
14.八皇后的问题 
15.找出来数组中每个元素后边第一个比它大的值 
16.给你一个二叉树，从上往下看，然后左往右顺序输出你能看到节点，同一个竖直方向上上面的节点把下面的节点遮挡住了 
17.链表反转，分别用遍历与递归实现 
18.完全二叉树的最大深度与节点个数 
19.两个栈实现队列 
20.两个有序数组交集、并集 
21.给定一个有序存在重复的值链表，使得每个元素只出现一次 
22.leetcode 200 
23.二叉搜索树转有序双向链表 
24.字符串全排列 ，可能有重复的，要去重 
25.二叉搜索树第k个节点，不用中序遍历 
26.有序数组查找重复元素个数 
27.定长数组实现队列 
28.用二分法对一个数字开根号 
29.判断一颗树是不是二叉搜索树 
30.Excel表的列字母转换，输入第几列，输出列字母组合 
31.链表第k-1个节点 
32.手撕快排 
33.二分查找 
34.一个无序有正有负数组，求乘积最大的三个数的乘积 
35.求二叉树的深度，不使用递归 
36.实现链表，无序链表，对链表值奇偶分离并排序，空间复杂度O(1) 
37.单调不递减数组，给一个target，找出大于等于target的下标index 
38.单调不递减链表，删除掉重复值 
39.无序数组构建一棵二叉排序树 
40.行和列都是有序的二维矩阵找一个target值 
41.是否是回文链表 
42.打印出根节点到叶子节点的最长路径 
43.双链表按照奇偶顺序分成两个链表，要求不要复制链表 
44.不严格递增数组，要求删除出现次数大于k的数字，要求不要新建存储空间 
45.链表相邻元素交换 
46.二叉树的最小公共祖先 
47.字符串形式自定义进制大数相加 
48.链表每隔k个反转 
49.输出根节点到叶子节点路径之和为target的路径列表 
50.一些数，任意排列求可形成最小的值 
51.LeetCode  1038. 
52.数组题，任意一个整型数组，判断是否可以将数组分为三个区间，每个区间中数值的和相同 
53.已排序的整数数组去重 
54.错位的全排列（第一位不能是1，第二位不能是2） 
55.k路链表归并 
56.非降序数组，找与target最相近的数的下标 
57.二叉树逆时针打印最外层节点 
58.输入一个数字n，构建一个完全二叉树并输出 
59.输入一个矩阵，起始点和目标点，判断是否存在可达路径 
60.无向图最短路径 
61.第K层叶子节点个数



1.extern "c"的作用是什么? extern代表什么意思？c和c++有什么区别？

在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。

比如说你用C 开发了一个DLL 库，为了能够让C ++语言也能够调用你的DLL 输出(Export) 的函数，你需要用extern "C" 来强制编译器不要修改你的函数名。

 int  Fun(int  i,int  j)  
 C：_Fun  
 C++：_Fun_int_int  

-   C是面向过程的语言，而C++是面向对象的语言。所以C++支持继承和多态。C++拥有非常强大的STL模版库。
-   C++有非常强大的设计模式，比如单例，工厂，观察者模式等等，这些在C语言当中都是不支持的。
-   C和C++一个典型的区别就在动态内存管理上了，C语言通过malloc和free来进行堆内存的分配和释放，而C++是通过new和delete来管理堆内存的。
-   另外强制类型转换上也不一样，C的强制类型转换使用()小括号里面加类型进行类型强转的，而C++有四种自己的类型强转方式，分别是const_cast，static_cast，reinterpret_cast和dynamic_cast。
-   C++还支持带有默认值的函数，函数的重载，inline内联函数，这些C语言都不支持，当然还有const这个关键字，C和C++也是有区别的。
-   C++不仅支持指针，还支持更安全的引用，不过在汇编代码上，指针和引用的操作是一样的。
-   在C++中，struct关键字不仅可以用来定义结构体，它也可以用来定义类。

2.  什么是多态

C++ 中的多态性具体体现在编译和运行两个阶段。编译时多态是静态多态，在编译时就可以确定使用的接口。运行时多态是动态多态，具体引用的接口在运行时才能确定。

静态多态和动态多态的区别其实只是在什么时候将函数实现和函数调用关联起来，是在编译时期还是运行时期，即函数地址是早绑定还是晚绑定的。静态多态是指在编译期间就可以确定函数的调用地址，并生产代码，这就是静态的，也就是说地址是早绑定。静态多态往往也被叫做静态联编。 动态多态则是指函数调用的地址不能在编译器期间确定，需要在运行时确定，属于晚绑定，动态多态往往也被叫做动态联编。

为何要使用多态呢？封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。静态多态，将同一个接口进行不同的实现，根据传入不同的参数（个数或类型不同）调用不同的实现。动态多态，则不论传递过来的哪个类的对象，函数都能够通过同一个接口调用到各自对象实现的方法。

静态多态往往通过函数重载和模版（泛型编程）来实现

动态多态是通过“继承+虚函数”来实现的，只有在程序运行期间（非编译期）才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。具体格式就是使用 virtual 关键字修饰类的成员函数时，指明该函数为虚函数，并且派生类需要重新实现该成员函数，编译器将实现动态绑定。

3.c可不可以重载

学过C语言和C++的人都知道，
C++支持函数重载而C语言不支持函数重载。
而所谓的函数重载就是指：
在同一作用域类，一组函数的函数名相同，参数列表不同（个数不同或类型不同），返回值可同可不同。
那么问题来了，为什么C++支持函数重载，而C语言不支持呢？
从代码的编译到运行，在VC6.0或VS这种编译器下，它是系统直接完成了翻译与链接，直接生成了运行结果。
编译器内部完成了翻译部分：
1.预处理
  1）头文件展开
  2）宏的替换
  3）去注释
  4）条件编译
2.编译过程：将高级语言转为汇编语言
3.汇编过程：汇编语言转为二进制程序
链接部分：所引用的数据链接进来
比如一个函数的声明如下：
void  function(int x,int y)；


在c语言中，编译器在编译后在库中的名字为_function
在c++中，编译器在编译后在库中的名字为_function_int_int
还有一个函数的声明如下：
void function（float x,float y)；
在c语言中，编译器在编译后在库中的名字为_function
在c++中，编译器在编译后在库中的名字为_function_float_float
在链接时，都是找名字进行链接的,就比如以上两个函数，
在C语言中两个的名字一样，就会在链接中报错。
C++中它们的名字不一样，所以就不会报错。

4、基类析构函数不是虚函数会怎么样，有什么后果？

编译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。

所以建议的方式是将析构函数声明为虚函数。如果你使用MFC，并且以CObject或其派生类为基类，那么MFC已经为你做了这件事情；CObject的析构函数是虚函数。一个函数一旦声明为虚函数，那么不管你是否加上virtual 修饰符，它在所有派生类中都成为虚函数。但是由于理解明确起见，建议的方式还是加上virtual 修饰符。

C++不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和C语言的类型的兼容性。有虚函数的对象总是在开始的位置包含一个隐含的虚函数表指针成员。如果是对于MFC类CPoint和CSize这样的小型类，增加一个指针就增加了很多内存占用，而且使得其内存表示和基类POINT和SIZE不一致。如果两个类的内存表示一致，那么这样你可以安全地把一个类的指针或数组当作另一个类的指针或数组使用。



5、全局变量为什么还要加上static关键字，有什么区别？

静态全局变量不能被其它文件所用；

其它文件中可以定义相同名字的变量，不会发生冲突；



6、说一种网络分层，详细说一说TCP，IP



7、IP地址和MAC地址有什么区别，有了MAC地址为什么还要有IP地址

\1. 有了MAC地址为什么还需要IP地址？

由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要是这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的IP地址把这个复杂问题解决了。连接到因特网的主机只需拥有统一的IP地址，它们之间的通信就像连接在同一个网络（虚拟互连网络或者简称IP网）上那么简单方便，因为调用ARP的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。

\2. 有了IP地址为什么还需要MAC地址？

a.信息传递时候，需要知道的其实是两个地址：终点地址、下一跳的地址。IP地址本质上是终点地址，它在跳过路由器的时候不会改变，而MAC地址则是下一跳的地址，每跳过一次路由器都会改变。这就是为什么还要用MAC地址的原因之一，它起到了记录下一跳的信息的作用。 
b.网络体系结构的分层模型：用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与数据链路层的协议更灵活地替换。 
c.历史原因：早期的以太网只有集线器，没有交换机，所以发出去的包能被以太网内的所有机器监听到，因此要附带上MAC地址，每个机器只需要接受与自己MAC地址相匹配的包。



### 既然mac地址唯一，为什么还要有IP地址?

之前我们提到，mac地址是唯一的，那理论上，在任何两个设备之间，我应该都可以通过mac地址发送数据，为什么还需要ip地址？

mac地址就好像个人的身份证号，人的身份证号和人户口所在的城市，出生的日期有关，但是和人所在的位置没有关系，人是会移动的，知道一个人的身份证号，并不能找到它这个人，mac地址类似，它是和设备的生产者，批次，日期之类的关联起来，知道一个设备的mac，并不能在网络中将数据发送给它，除非它和发送方的在同一个网络内。

所以要实现机器之间的通信，我们还需要有ip地址的概念，ip地址表达的是当前机器在网络中的位置，类似于城市名+道路号+门牌号的概念。通过ip层的寻址，我们能知道按何种路径在全世界任意两台Internet上的的机器间传输数据。

mac地址通常是不变的，ip地址是可变的，尤其是移动设备，ip地址会经常变更。

mac地址的设计不携带设备在网络中的位置信息，想要通过mac地址通信，我们得在所有的设备上维护一张很大的表，记录所有mac地址路由在当前位置的的下一跳，这显然是不合理的。

### 既然能通过ip地址发送数据，为什么要有mac地址

既然ip地址有位置信息，而且在一个网络中也是唯一的，那么我们为什么不完全通过ip地址通信，抛弃mac地址呢？或者说，合并ip层和mac层的功能。

-   历史原因
    最初的链路层协议是和ip地址无关的，没有网络层方面的设定，只有物理层和链路层，最初也只有集线器，没有交换机路由器，服务器之间传输数据全靠mac地址。在没有ip地址之前，mac地址已经在使用了。现在到处都在用的二层交换机，就是根据mac地址转发数据。
-   设计的原因
    现在这样设计是好的设计，链路层的实现不需要考虑数据之间的转发，网络层的实现不需要考虑物层的影响。

8、http1.x和http2.0的区别

9、tcp和udp的区别

1.基于连接与无连接； 
2.对系统资源的要求（TCP较多，UDP少）； 
3.UDP程序结构较简单； 
4.流模式与数据报模式 ； 
5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

1.  close_wait过多原因

>   close_wait 按照正常操作的话应该很短暂的一个状态，接收到客户端的fin包并且回复客户端ack之后，会继续发送fin包告知客户端关闭关闭连接，之后迁移到Last_ACK状态。但是close_wait过多只能说明没有迁移到Last_ACK，也就是服务端是否发送fin包，只有发送fin包才会发生迁移，所以问题定位在是否发送fin包。fin包的底层实现其实就是调用socket的close方法，这里的问题出在没有执行close方法。说明服务端socket忙于读写。

1.  close_wait过多的解决方案

>   1.  代码层面做到第一：使用完socket调用close方法；第二：socket读控制，当读取的长度为0时（读到结尾），立即close；第三：如果read返回-1，出现错误，检查error返回码，有三种情况：INTR（被中断，可以继续读取），WOULDBLOCK（表示当前socket_fd文件描述符是非阻塞的，但是现在被阻塞了），AGAIN（表示现在没有数据稍后重新读取）。如果不是AGAIN，立即close
>   2.  可以设置TCP的连接时长keep_alive_time还有tcp监控连接的频率以及连接没有活动多长时间被迫断开连接

1.  Time_Wait停留时间长的原因（2MSL大约1-4分钟，数据包在IP传输的最长生命时长）

>   1.  为了防止最后一个ACK没有送到服务端，如果客户端立即关闭的话，服务端会重新发fin包，这时客户端关闭，服务端会收到RST，也就是一个报错
>   2.  为了防止当前连接中的重复报文干扰下一个连接



2、网络分层模型，对应的协议
 3、协议的幂等性质 
 4、HTTP协议连接的过程
 5、HTTP返回码
 6、如何判断是不是同一个TCP连接
 （我说的socket比较）
 7、TCP重传怎么做
 自动重传、立刻重传
 8、数据库四大特性
 9、脏读和幻读
 10、行锁和间隙锁，怎么加行锁
 什么情况下产生间隙锁
 11、手撕一个快排