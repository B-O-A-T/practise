优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。

 

当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。

问题是怎么扫描的行数呢？

 

MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。

 

**这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality****）。**也就是说，这个基数越大，索引的区分度越好。



索引统计的更新机制，并提到了优化器存在选错索引的可能性。

 

**对于由于索引统计信息不准确导致的问题，你可以用analyze table**来解决。

 

**而对于其他优化器误判的情况，你可以在应用端用force index****来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。

nnoDB支持的索引有：B+树索引，全文索引，哈希索引（自适应的）

B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页，然后通过把页读入到内存，再内存中进行查询，最后得到要查询的数据。

二分查找

二叉查找树

平衡二叉树

B+树在数据库中有一个特点是高扇出性，高度一般在2~4层。可以分为聚集索引和辅助索引，不同点是叶子节点存放的是否是一整行的信息。

聚集索引优点：

1、能够在B+树索引的叶子节点上直接找到树

2、范围查询

聚集索引的存储并不是物理上连续 的，而是逻辑上连续的

辅助索引：

1、叶子节点不包含行记录的全部数据。除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签。

InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键

可以用多个辅助索引



并发是B+树索引实现最为困难的部分



Cardinality，表示索引中不重复记录数量的预估值

MySQL中是在存储引擎层中统计的，通过采样的方法来完成的，更新发生在两个操作中：INSERT和UPDATE

更新策略：表中1/16的数据已发生过改变；stat_modified_counter>2000000000

ANALYZE TABLE

SHOW TABLE STATUS

SHOW INDEX

访问INFORMATION SCHEMA架构下的表TABLES和STATISTICS



联合索引

覆盖索引



Multi-Range Read 优化

Index Condition Pushdown





not exists  除

not in		差