# 索引代价估计

索引是为了加速对表中数据行的检索而创建的一种分散的存储结构。索引是针对表而建立的，它是由数据页面以外的索引页面组成的，每个索引页面中的行都会含有逻辑指针，以便加速检索物理数据。都知道索引能够加速查询，也知道索引是有缺点的，即说明了索引的建立与否是一个trade-off的过程。

本文思考了一种索引的收益和代价估计模型，欢迎交流。

索引是针对查询的，那么想要建立一个最佳索引，就需要计算索引的收益和成本，这里定义收益为索引能为单条查询执行所减少的时间，而成本是每个索引所占用的空间大小。那么我们怎么样能够不实际建立索引，然后去计算收益和成本呢？

首先需要计算索引选择率

##### 选择率计算方法

无参数方法，ad hoc数据结构或直方图维护属性值分布

参数法。使用具有一些自由统计参数（参数是预先估计出来的）的数学分布函数逼近真实分布

曲线拟合法

抽样法

综合法

PostgreSQL通过（等频）直方图、最频值和空置率等统计信息来进行选择率的计算。

l 当过滤条件为等值条件

例如过滤条件为date_dim.d_moy=12，从统计信息中获取表date_dim的d_moy列不同值个数为                                ，我们假设表数据是平坦的，该等值条件的选择率为：

 

l 当过滤条件为范围条件

例如过滤条件为store_sales.ss_sold_date_sk<=2451050，从统计信息中获取表store_sales的ss_sold_date_sk列最大最小值分别为  和  ，  为2451050，该范围条件的选择率为：

 

同理，>=范围条件选择率为

 

然后，普通索引表的并不包含所需的所有列，则需要通过回表的过程去访问原表。所以此处的代价可以分为IO代价，CPU代价，回表代价，以及排序代价。



索引种类

查询代价估计

代价估计模型

总代价 = IO代价 + CPU代价
$$
COST = P*aPageCpuTime + W*T
$$
P为计划运行时访问的页面数，aPageCpuTime是每个页面读取的时间花费

T为访问的元组数

W为权重因子，表明IO到CPU的相关性，又称选择率





索引扫面
$$
CIndex + NPageIndex * aTupleIOTime
$$




索引的选择本身是一个在收益和代价之间做权衡的过程。索引的收益来自于查询性能的提升，索引代价来自于额外的占用空间和对事务更新性能的影响。



全表扫描代价

基本表的全表扫描代价为FullTableScanCost ，主要包含CPU代价CpuRunCost  和磁盘IO代价 IOCost ：
$$
FullTableScanCost = K * CpuRunCost + IOCost
$$


其中 K 为CPU代价和IO代价的比例系数。

l 磁盘IO代价

磁盘IO代价  计算方法如下：
$$
IOCost = Size(R)/4k * Cpage
$$
其中 Cpage 为页代价系数。

l CPU代价：
$$
CpuRunCost = Tuples(R) * (FilterCost + Ctuple)
$$

$$
FilterCost = NUMf * Ccpu
$$



其中Ctuple为单个元组操作代价，Ccpu为CPU操作代价，NUMf为一张表中过滤条件的数量。

l 使用索引代价

在Cedar中，索引表也是基本表，所以使用索引的代价分为扫描索引表的代价和索引回表代价，但由于过滤条件覆盖索引前缀列，因此索引表不需要做全面扫描：

 

 



（2）索引代价

索引代价主要是估算索引所占用的空间大小，通过统计信息获取原表行数  ，通过索引表每一列数据类型估算每行数据大小  ，最终索引表大小估算公式为：

 

空间代价 写入性能代价





I
