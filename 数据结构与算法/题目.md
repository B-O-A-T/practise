## 1.两数之和 

解题思路：哈希数组 hash[nums[x]]  = x

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> m;
        for(int i=0;i<nums.size();i++)
            m[nums[i]] = i;         //向map中添加元素
        for(int i=0;i<nums.size();i++)
        {
            if(m.find(target-nums[i]) != m.end() && m[target-nums[i]] != i)     //如果m中存在对应的键值，并且不为i
                return {i , m[target-nums[i]]};
        }
        return {};
    }
};
```

## 2.两数相加 

解题思路：大数相加？竖式计算

```C++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head=new ListNode(-1);//存放结果的链表
        ListNode* h=head;//移动指针
        int sum=0;//每个位的加和结果
        bool carry=false;//进位标志
        while(l1!=NULL||l2!=NULL)
        {
            sum=0;
            if(l1!=NULL)
            {
                sum+=l1->val;
                l1=l1->next;
            }
            if(l2!=NULL)
            {
                sum+=l2->val;
                l2=l2->next;
            }
            if(carry)
                sum++;
            h->next=new ListNode(sum%10);
            h=h->next;
            carry=sum>=10?true:false;
        }
        if(carry)
        {
            h->next=new ListNode(1);
        }
        return head->next;
    }
};
```

## 3.无重复字符的最长子串

解题思路：滑动窗口

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> hm(128,0);
        int i = 0;
        int ans = 0;
        for (int j = 0; j < s.size(); ++j) {
            i = max(i, hm[s[j]]);
            hm[s[j]] = j + 1;
            ans = max(ans, j-i+1);
        }
        return ans;
    }
};
```

## 最长回文子串 

解题思路：1、枚举中心，注意分奇偶；2、动态规划

```C++
class Solution {
  public:
    string longestPalindrome(string s) {
        string res;
        for (int i = 0; i < s.size(); ++i) {
            // 枚举单数情况
            for (int j = i, k = i; j >= 0 && k < s.size() && s[j] == s[k];
                 j--, k++) {
                if (res.size() < k - j + 1) {
                    res = s.substr(j, k - j + 1);
                }
            }

            // 枚举偶数情况
            for (int j = i, k = i + 1; j >= 0 && k < s.size() && s[j] == s[k];
                 j--, k++) {
                if (res.size() < k - j + 1) {
                    res = s.substr(j, k - j + 1);
                }
            }
        }
        return res;
    }
};
```



## 整数反转

```C++
// 32位整数范围 -2147483648 ~ 2147483647
#include <bits/stdc++.h>
class Solution {
public:
    int reverse(int x) {
        int res = 0;
        while (x!=0) {
            int pop = x % 10;
            x /= 10;
            // 移除判断
            if (res > INT_MAX/10 || (res == INT_MAX / 10 && pop > 7)) return 0;
            if (res < INT_MIN/10 || (res == INT_MIN / 10 && pop < -8)) return 0;
            res = res * 10 + pop;
        }
        return res;
    }
};
```

## 回文数

思路：反转一半数字

```C++
class Solution {
public:
    bool isPalindrome(int x) {
        // string x_str = to_string(x);
        // int i = 0, j = x_str.size()-1;
        // while(i<j) {
        //     if(x_str[i]==x_str[j]) {
        //         i++;
        //         j--;
        //     } else {
        //         return false;
        //     }
        // }
        // return true;
        // 边界判断
        if (x<0 || (x%10 == 0 && x!=0))
            return false;
        
        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x%10;
            x = x/10;
        }
        return x==revertedNumber || x==revertedNumber/10;
    }
};
```

## 盛最多水的容器 

思路：双指针

```C++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0;
        int r = height.size()-1;

        int ans = 0;
        while(l<r){
            int max_value = (r-l)*min(height[l],height[r]);
            ans = max(ans, max_value);
            // 维持一个相对高点
            if (height[l]<=height[r]){
                l++;
            }else {
                r--;
            }
        }
        return ans;
    }
};
```



## 最长公共前缀 

思路：纵向扫描

```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        int len = strs.size();
        if (len == 0) return "";
        for (int i = 0; i< strs[0].size(); ++i) {
            int c = strs[0][i];
            for (int j = 1; j < len; ++j) {
                if (i == strs[j].size() || c != strs[j][i]){
                    return strs[0].substr(0, i);
                }
            }
        }
        return strs[0];
    }
};
```



## 三数之和 

思路：排序+双指针

```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int len = nums.size();
        vector<vector<int>> ans;
        if(len<3) return ans;
        sort(nums.begin(), nums.end());

        for (int i = 0; i< len; ++i) {
            if (nums[i]>0) break;
            // 防止重复枚举
            if (i>0 && nums[i] == nums[i-1]) continue;
            int first = i;
            int second = first + 1;
            int third = len - 1;
            while(second < third) {
                // 三数之和
                int sum = nums[first] + nums[second] + nums[third];
                // cout<< nums[first] << " " << nums[second] << " " << nums[third]<<endl;
                if (sum == 0) {
                    // 满足条件加入结果集
                    ans.push_back({nums[first], nums[second], nums[third]});
                    // 移动第二个指针，找到不重复的点
                    while(second < third && nums[second] == nums[second + 1]) second++;
                    // 移动第三个指针，找到不重复的点
                    while(second < third && nums[third] == nums [third - 1]) third--;
                    second++;
                    third--;
                } else if (sum>0) {
                    third--;
                } else {
                    second++;
                }
            }
        }
        return ans;
    }
}
```



## 最接近的三数之和 

思路：排序+双指针，然后记录最小差值，如果为0，直接返回

```C++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int len = nums.size();
        if (len <3) return -1;

        sort(nums.begin(), nums.end());
        int left,right;
        int sub = INT_MAX,sum, res;
        vector<int> ans(3);
        for (int i= 0; i<len -2; ++i) {
            left = i +1;
            right = len-1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                // cout<<nums[i]<<" + "<<nums[left]<<" + "<<nums[right]<< " = "<<sum<<endl;
                // cout<<abs(target - sum) <<endl;
                if ( abs(target - sum) < sub) {
                    sub = abs(target - sum);
                    // cout<< sub<<endl;
                    res = sum;
                    ans[0] = nums[i];
                    ans[1] = nums[left];
                    ans[2] = nums[right];
                }
                if ( sum == target  ){
                    ans[0] = nums[i];
                    ans[1] = nums[left];
                    ans[2] = nums[right];
                    res = sum;
                    return res;
                } else if (sum >target) {
                    right--;
                } else {
                    left++;
                }
            }
            
        }

        return res;
    }
};
```



## 电话号码的字母组合 

思路：回溯

```C++
class Solution {
public:
    //1. 用map记录每个数字按键对应的所有字母
    map<char, string> M = {
        {'2', "abc"}, {'3', "def"}, {'4', "ghi"}, {'5', "jkl"}, {'6', "mno"},
        {'7', "pqrs"}, {'8', "tuv"}, {'9', "wxyz"}
    };
    //2. 存储最终结果和临时结果的变量
    vector<string> ans;
    string current;

    //3. DFS函数，index是生成临时结果字串的下标，
    //每一个digits[index]数字对应临时结果current[index]的一位字母
    void DFS(int index, string digits) {
        //出口
        if(index == digits.size()) {
            ans.push_back(current);
            return;
        }
        //递归调用
        //对于当前输入的第index号数字(digits[index])，
        //枚举其对应的所有字母(M[digits[index]][i])
        for(int i = 0; i < M[digits[index]].size(); i++) {
            current.push_back(M[digits[index]][i]);     //临时结果压入一个字母
            DFS(index + 1, digits);         //以在当前位置压入该字母这一“情况”为前提，构造此“分支”的后续结果
            current.pop_back();             //状态还原，例如临时结果从 "ab" -> "a"，下一次循环尝试"ac" 
        }
    }

    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0) {
            return ans;
        }
        DFS(0, digits);
        return ans;
    }

};
```

思路：暴力

```C++
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        if (digits.empty()) return {};
        vector<vector<char>> d(10);
        d[0] = {' '};
        d[1] = {};
        d[2] = {'a','b','c'};
        d[3] = {'d','e','f'};
        d[4] = {'g','h','i'};
        d[5] = {'j','k','l'};
        d[6] = {'m','n','o'};
        d[7] = {'p','q','r','s'};
        d[8] = {'t','u','v'};
        d[9] = {'w','x','y','z'};

        vector<string> state(1,"");
        for(auto u:digits){
            vector<string> now;
            for(auto c: d[u-'0']){
                for(auto s: state){
                    now.push_back(s+c);
                }
            }
            state = now;
        }
        return state;
    }
};
```



## 四数之和 

思路：双指针

```C++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++) {
            // 这中剪枝是错误的，这道题目target 是任意值 
            // if (nums[k] > target) {
            //     return result;
            // }
            // 去重
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            for (int i = k + 1; i < nums.size(); i++) {
                // 正确去重方法
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    if (nums[k] + nums[i] + nums[left] + nums[right] > target) {
                        right--;
                    } else if (nums[k] + nums[i] + nums[left] + nums[right] < target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 去重逻辑应该放在找到一个四元组之后
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }

            }
        }
        return result;
    }

};
```



## 删除链表的倒数第 N 个节点

思路：快慢指针，一个指针先走n步

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        auto dummy = new ListNode(-1);
        dummy->next = head;

        auto first = dummy, second = dummy;
        while(n--){first = first ->next;}
        while(first->next){
            first = first->next;
            second = second->next;
        } 
        second ->next = second->next->next;

        return dummy->next;
    }
};
```



## 有效的括号

思路：栈

```C++
class Solution {
public:
    bool isValid(string s) {
        stack<char>s1;
	int len = s.length();
	for (int i = 0; i < len; i++) {
		char c = s[i];
		if (c == '{' || c == '[' || c == '(') {
			s1.push(c);
		}
		else {
			if (s1.empty())
				return false;
			char left = s1.top();
			s1.pop();
			if (left == '(' && c != ')')return false;
			if (left == '{' && c != '}')return false;
			if (left == '[' && c != ']')return false;
		}
	}
	return s1.empty();
    }
};
```



## 合并两个有序链表 

思路：迭代，递归

```C++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // ListNode *preHead =new ListNode(-1);
        // ListNode* ahead = preHead;

        // while(l1!=NULL && l2!=NULL){
        //     if(l1->val < l2->val){
        //         ahead->next = l1;
        //         l1 = l1->next;
        //     } else {
        //         ahead->next = l2;
        //         l2 = l2->next;
        //     }
        //     ahead = ahead -> next;
        // }

        // if(l1) ahead->next = l1;
        // if(l2) ahead->next = l2;

        // return preHead->next;

        if(l1==NULL){
            return l2;
        }
        if(l2==NULL){
            return l1;
        }
        if(l1->val<l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};
```



## 括号生成 

思路：回溯

```C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        int right = n;
        int left = n;
        vector<string> result;
        generate("", left, right, result);
        return result;
    }

private:
    void generate(string item, int left, int right, vector<string> &result){
        if(left==0 && right ==0){
            result.push_back(item);
            return ;
        }
        if(left>0){
            generate(item+"(",left-1,right,result);
        }
        if(left<right){
            generate(item+")",left,right-1,result);
        }
    }
};
```



## 两两交换链表中的节点 

思路：递归、迭代

```C++
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode next = head.next;
        head.next = swapPairs(next.next);
        next.next = head;
        return next;
    }
}
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode pre = new ListNode(0);
        pre.next = head;
        ListNode temp = pre;
        while(temp.next != null && temp.next.next != null) {
            ListNode start = temp.next;
            ListNode end = temp.next.next;
            temp.next = end;
            start.next = end.next;
            end.next = start;
            temp = start;
        }
        return pre.next;
    }
}
```



## 删除排序数组中的重复项 

思路：双指针

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (!nums.size ()) return 0;

        int k = 1;
        for (int j = 1;j<nums.size();++j){
            if(nums[j-1]!=nums[j])
                nums[k++] = nums[j];
        }  
        return k;  
    }
};
```



下一个排列

思路：从最末位寻找第一个破坏升序的数nums[pos - 1], 然后在遍历过的数里寻找比该数大的最小的一个数。
如遍历过的数为[7,6,4,3], nums[pos - 1]为5, 则5需要与6进行交换, 在将[7,5,4,3]改为升序(这里使用reverse)。

遍历过的数从后往前一定是升序, 故改为从前往后升序只需要反转该部分即可。
寻找第一个比nums[pos - 1]大的数, 只需改为从前往后升序之后, 从升序的第一个数开始遍历比较大小即可。

```C++
class Solution {
public:
	void nextPermutation(vector<int>& nums) {
		int pos = nums.size() - 1;
		while (pos > 0 && nums[pos] <= nums[pos - 1])
			pos--;
		reverse(nums.begin() + pos, nums.end());  //逆序
		if (pos > 0){
			int start = pos;
			for (; start < nums.size(); start++){ //寻找第一个大于nums[pos - 1]的数
				if (nums[start] > nums[pos - 1]){
					swap(nums[start], nums[pos - 1]); //交换
					break;
				}
			}
		}
	}
};
```



搜索旋转排序数组 

思路：先根据 nums[mid] 与 nums[l] 的关系判断 mid 是在左段还是右段，接下来再判断 target 是在 mid 的左边还是右边，从而来调整左右边界 l 和 r。

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) return -1;
        if (n == 1) return nums[0] == target ? 0 : -1;
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```



在排序数组中查找元素的第一个和最后一个位置

思路：二分，注意细节

```C++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if (nums.size()==0) return {-1,-1};
		// 搜索第一个满足条件的位置
        int l = 0, r = nums.size()-1;
        while(l<r){
            int mid = l+r>>1;
            if(nums[mid]>=target)
                r = mid;
            else 
                l = mid+1;
        }

        if(nums[r]!=target)
            return {-1,-1};
        // 搜索最后一个满足条件的位置
        int x = 0, y = nums.size()-1;
        while(x<y){
            int mid = x+y+1>>1;
            if(nums[mid]<=target){
                x = mid;
            } else {
                y = mid-1;
            }
        }
        return {l,x};
    }
};
```



搜索插入位置 

思路：二分，「在一个有序数组中找第一个大于等于 target 的下标」

```C++
class Solution {
public:
    int searchInsert(vector<int> &nums, int target) {
        int size = nums.size();
        if (size == 0) {
            return 0;
        }

        // 特判
        if (nums[size - 1] < target) {
            return size;
        }
        int left = 0;
        int right = size - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            // 严格小于 target 的元素一定不是解
            if (nums[mid] < target) {
                // 下一轮搜索区间是 [mid + 1, right]
                left = mid + 1;
            } else {
                // 下一轮搜索区间是 [left, mid] 
                right = mid;
            }
        }
        return left;
    }
};
```



外观数列

思路：递归＋计数

```C++
class Solution {
public:
    string countAndSay(int n) {
        if(n == 1) return "1";

        string previous = countAndSay(n-1), result = ""; // 使用递归来一层一层往前推
        int count = 1; // count用来计数

        for(int i=0;i<previous.length();i++)
        {
            if(previous[i] == previous[i+1])
            {
                count ++; // 比如previous是111221时，111部分会让count=3，此时i在第三个1处
            }
            else
            {
                result += to_string(count) + previous[i]; // result会从空变成“31”（当i在第三个1处时）
                count = 1; // 由于i在第三个1处时，i+1处的值为2，1 != 2，所以count重新变成1
            }
        }

        return result;
    }
};
```



组合总和 

思路：回溯

```C++

class Solution {
private:
    vector<int> candidates;
    vector<vector<int>> res;
    vector<int> path;
public:
    void DFS(int start, int target) {
        if (target == 0) {
            res.push_back(path);
            return;
        }
        for (int i = start;
             i < candidates.size() && target - candidates[i] >= 0; i++) {
            path.push_back(candidates[i]);
            DFS(i, target - candidates[i]);
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int> &candidates, int target) {
        std::sort(candidates.begin(), candidates.end());
        this->candidates = candidates;
        DFS(0, target);

        return res;
    }

};
```



组合总和 II 

思路：同上

```C++
class Solution {

private:
    vector<int> candidates;
    vector<vector<int>> res;
    vector<int> path;
public:
    void DFS(int start, int target) {
        if (target == 0) {
            res.push_back(path);
            return;
        }

        for (int i = start; i < candidates.size() && target - candidates[i] >= 0; i++) {
            if (i > start && candidates[i] == candidates[i - 1])
                continue;
            path.push_back(candidates[i]);
            // 元素不可重复利用，使用下一个即i+1
            DFS(i + 1, target - candidates[i]);
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int> &candidates, int target) {
        sort(candidates.begin(), candidates.end());
        this->candidates = candidates;
        DFS(0, target);
        return res;
    }
};
```



全排列

思路：回溯

```C++
class Solution {
public:
    void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len){
        // 所有数都填完了
        if (first == len) {
            res.emplace_back(output);
            return;
        }
        for (int i = first; i < len; ++i) {
            // 动态维护数组
            swap(output[i], output[first]);
            // 继续递归填下一个数
            backtrack(res, output, first + 1, len);
            // 撤销操作
            swap(output[i], output[first]);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int> > res;
        backtrack(res, nums, 0, (int)nums.size());
        return res;
    }
};

class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<bool> flag;
    vector<vector<int>> permute(vector<int>& nums) {
        if(nums.size()==0)
            return {};

        int n = nums.size();
        for(int i=0;i<n;++i){
            flag.emplace_back(false);
        }
        dfs(nums, 0);
        return res;
    }

    void dfs(vector<int>& nums, int u){
        if(u==nums.size()){
            res.emplace_back(path);
            return;
        }
        for(int i=0;i<nums.size();++i){
            if(!flag[i]){
                flag[i]=true;
                path.emplace_back(nums[i]);
                dfs(nums, u+1);
                flag[i] = false;
                path.pop_back();
            }
            
        }
    }
};
```



旋转图像

思路：一层一层转换

```C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int pos1=0,pos2=matrix.size()-1;
        int add,temp;
        while(pos1<pos2){
            add = 0;
            while(add < pos2-pos1){
                temp = matrix[pos2-add][pos1];
                matrix[pos2-add][pos1] = matrix[pos2][pos2-add];
                matrix[pos2][pos2-add] = matrix[pos1+add][pos2];
                matrix[pos1+add][pos2] = matrix[pos1][pos1+add];
                matrix[pos1][pos1+add] = temp;
                add++;
            }  //左上角为0块，右上角为1块，右下角为2块，左下角为3块               
            pos1++;
            pos2--;
        }
            
    }
};
```



字母异位词分组

解题思路1
先遍历strs，对每个string进行排序，异位词的排序结果是一样的，在map中的key值也就一样，然后在map中添加对应的vector，再将vector逐个添加到res中

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map <string,vector<string> > m;
        for(string& s : strs)
        {
            string t = s;
            sort(t.begin(),t.end());
            m[t].push_back(s);   //t为单词的按顺序排列，作为key值，m[t]则为该单词的异位词构成的vector，作为value值
        }
        for(auto& n : m)                //n为键和值组成的pair
            res.push_back(n.second);
        return res;
    }
};
```


解题思路2
对26个字母分别赋予对应的质数值，因为不同的质数积必定为不同的数字结果，所以可以用来作为map的key值

质数相乘（效率更高）

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map <double,vector<string> > m;
        double a[26]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};
        for(string& s : strs)
        {
            double t = 1;
            for(char c : s)
            t *= a[c - 'a'];

        m[t].push_back(s);          //t为单词对应的质数乘积，m[t]则为该单词的异位词构成的vector
    }
    for(auto& n : m)                //n为键和值组成的pair
        res.push_back(n.second);
    return res;
}

};
```



Pow(x, n) 

思路：快速幂

```C++
class Solution {
public:
    double quickMul(double x, long long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```



最大子序和

思路：

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = INT_MIN;
        int sum = 0;
        for(int i=0, j = 0;i<nums.size();++i){
            sum +=nums[i];
            res = max(sum,res);
            if(sum<0){
                sum = 0;
            }
        }
        return res;
    }
};
```



螺旋矩阵 

思路：模拟

```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int u = 0; //赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(true)
        {
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); //向下
            if(-- r < l) break; //重新设定有边界
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); //向左
            if(-- d < u) break; //重新设定下边界
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); //向上
            if(++ l > r) break; //重新设定左边界
        }
        return ans;
    }
};
```



跳跃游戏 

思路：贪心

```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
};
```



合并区间

思路：排序+双指针

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(!intervals.size()){
            return {};
        }
        sort(intervals.begin(), intervals.end());

        int L = intervals[0][0];
        int R = intervals[0][1];
        vector<vector<int>> ans;
        for(int i=1;i<intervals.size();++i){
            if(intervals[i][0]>R){
                ans.push_back({L,R});
                L = intervals[i][0];
                R = intervals[i][1];
            }
            else {
                R = max(R,intervals[i][1]);
            }
        }
        ans.push_back({L,R});
        return ans;
    }
};
```



旋转链表 

思路：双指针

```C++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head==nullptr) return nullptr;
        int n=0;
        for(auto p = head;p;p = p->next){
            n++;
        }

        k = k%n
        auto first = head, second = head;
        while(k--){second = second->next;}
        while(second->next){
            first = first->next;
            second = second->next;
        }
        second->next = head;
        head = first->next;
        first->next = nullptr;
    
        return head;
    }
};
```



不同路径 

```C++
class Solution {
public:
    // 1. 回溯，到达终点记录一次路径 （结果超时！）
    int uniquePaths(int m, int n) {
        int res=0;
        dfs(0, 0, m, n, res);
        return res;
    }
    
    void dfs(int i, int j, int row, int col, int& res){
        if(i==row-1&&j==col-1) {
            res++;
            return;
        }
        if(j<col) dfs(i, j+1, row, col, res);
        if(i<row) dfs(i+1, j, row, col, res);
    }

    // 2-1. 动态规划（二维空间）
    int uniquePaths(int m, int n) {
        vector<vector<int> > dp(m, vector<int>(n, 1));
        // for(int i=0;i<n;i++) dp[0][i]=1;
        // for(int j=1;j<m;j++) dp[j][0]=1;
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++) dp[i][j]=dp[i][j-1]+dp[i-1][j];
        }
        return dp[m-1][n-1];
    }

    // 2-2. 动态规划（一维空间）
    int uniquePaths(int m, int n) {
        int small=min(m, n);
        int large=max(m, n);
        vector<int> dp(small, 1);
        for(int i=1;i<large;i++){
            for(int j=1;j<small;j++) dp[j]+=dp[j-1]; 
        }
        return dp[small-1];
    }
};
```



最小路径和 

思路：dp

```C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size() ==0 || grid[0].size() ==0) return -1;
        int nr = grid.size();
        int nc = grid[0].size();

        vector<int> dp(nc +1, INT_MAX);
        dp[nc] = 0;
        for (int i = nr -1; i>=0; --i) {
            for (int j = nc -1; j>=0; --j) {
                if (j != nc -1)
                    dp[nc] = INT_MAX;
                dp[j] = min(dp[j], dp[j+1]) + grid[i][j];
                // cout<<i<<" "<<j<<" "<< grid[i][j]<<endl;
                // cout<<dp[i][j]<<endl;
            }
        }
        return dp[0];
    }
};
```



x 的平方根 

思路：二分

```C++
class Solution {
public:
    int mySqrt(int x) {
        int l = 0;
        int r = x;
        while (l<r) {
            long long mid = (long long) l+((r-l)>>1)+1;
            if(mid>x/mid) r = mid-1;
            else l = mid;
        }
        return l;
    }
};
```



爬楼梯 

思路：斐波那契数列

```C++
class Solution {
public:
    int climbStairs(int n) {
        int dp1 = 1, dp2 = 1;
        if (n==1) return 1;
        for (int i = 2; i<=n; ++i) {
            int temp = dp1 + dp2;
            dp1 = dp2;
            dp2 = temp;
        }
        return dp2;
    }
};
```



颜色分类 

思路：荷兰国旗问题

```C++
class Solution {
  public:
  /*
  荷兰三色旗问题解
  */
  void sortColors(vector<int>& nums) {
    // 对于所有 idx < p0 : nums[idx < p0] = 0
    // curr 是当前考虑元素的下标
    int p0 = 0, curr = 0;
    // 对于所有 idx > p2 : nums[idx > p2] = 2
    int p2 = nums.size() - 1;

    while (curr <= p2) {
      if (nums[curr] == 0) {
        swap(nums[curr++], nums[p0++]);
      }
      else if (nums[curr] == 2) {
        swap(nums[curr], nums[p2--]);
      }
      else curr++;
    }
  }
};
```



子集 

思路：二进制表示子集状态

```C++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        for(int i=0;i< 1<<nums.size();++i){
            vector<int> now;
            for(int j=0;j<nums.size();++j){
                if(i>>j&1){
                    now.push_back(nums[j]);
                }
            }
            res.push_back(now);
        }

        return res;
    }
};
```



单词搜索 

思路：递归回溯

```C++
class Solution {
public:
    int dx[4] = {-1,0,1,0};
    int dy[4] = {0,1,0,-1};
    int n,m;
    bool exist(vector<vector<char>>& board, string word) {
        if(board.empty()||board[0].empty()) return false;
        n = board.size();
        m = board[0].size();

        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(dfs(board, i, j, word, 0))
                    return true;
            }
        }
        return false;
    }

    bool dfs(vector<vector<char>>& board, int x, int y, string &word, int u){
        if(board[x][y]!=word[u]) return false;
        if(u == word.size()-1) return true;
        char t = board[x][y];
        board[x][y] = '.';
        for(int i=0;i<4;++i){
            int a = x + dx[i];
            int b = y + dy[i];
            if( a>=0 && a<n && b>=0 && b<m )
                if(dfs(board, a, b, word, u+1))
                    return true;
        }
        board[x][y] = t;

        return false;
    }
};
```



## 删除排序链表中的重复元素

```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        auto cur = head;

        while(cur){
            if(cur->next && cur->next->val == cur->val){
                cur->next = cur->next->next;
            } else {
                cur = cur->next;
            }
        }
        return head;
    }
};
```

```C++
class Solution {
public:
   ListNode* deleteDuplicates(ListNode* head) {
        ListNode* PCUR=new ListNode(0);
        PCUR->next=head;
        head=PCUR;
        ListNode *L,*R;
        while(PCUR->next != NULL)
        {
            L=PCUR->next;
            R=PCUR->next;
            while(R->next && R->next->val==L->val)
                R=R->next;
            //如果循环后，L与R节点相同，说明不重复
            if(L == R) PCUR=PCUR->next;
            //L与R节点不相同，将PCUR的next指向R->next,继续重复上述操作
            else 
            {
                PCUR->next=R->next;
                //C++没有内存回收机制，应该释放这些指针，虽然不释放能通过，但是应该养成好习惯
                while(L!=R)
                {
                    ListNode*tmp=L;
                    L=L->next;
                    delete tmp;
                }
                delete L;
            }
        }
        return head->next;
    }
};
```

## 分隔链表 

```C++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *h1 = new ListNode(-1); // 记录比x小的节点组成的链表
        ListNode *h2 = new ListNode(-1); // 记录比x大的节点组成的链表
        ListNode *p1 = h1, *p2 = h2;
        while (head) {
            if (head -> val < x) {
                p1 -> next = head;
                p1 = p1 -> next;
            } else {
                p2 -> next = head;
                p2 = p2 -> next;
            }
            head = head -> next;
        }
        // 将两个链表拼接起来
        p2 -> next = nullptr;
        p1 -> next = h2 -> next;
        return h1 -> next;
    }
};
```

## 合并两个有序数组 

思路：不开辟新的空间，从后往前合并

```C++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int index = m+n-1;
        m = m-1;
        n = n-1;
        while(m>=0&&n>=0){
            if(nums1[m]>= nums2[n]){
                nums1[index--] = nums1[m--];
            
            } else {
                nums1[index--] = nums2[n--];
            }
        }

        while(n>=0){
            nums1[index--] = nums2[n--];
        }
    }
};
```

## 子集 II 



```c++
class Solution {
public:

    vector<vector<int>> ans;
    vector<int>path;

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        dfs(nums, 0);
        return ans;
    }

    void dfs(vector<int > & nums, int u) {
        if(u==nums.size()){
            ans.push_back(path);
            return;
        }
        // 当前数字的个数
        int k = 0;
        while(u+k<nums.size()&&nums[u+k]==nums[u]) k++;

        for(int i=0;i<=k; ++i){
            dfs(nums, u+k);
            path.push_back(nums[u]);
        }
		// 恢复现场
        for(int i=0;i<=k;i++) path.pop_back();
    }
};
```

## 解码方法

思路：背后的思想是「分类计数加法原理」和「分步计数乘法原理」。

方法一：动态规划
第 1 步：定义状态

既然结尾的字符很重要，在定义状态的时候可以这样定义：

dp[i]：以 s[i] 结尾的前缀子串有多少种解码方法。

第 2 步：推导状态转移方程

根据题意：

如果 s[i] == '0' ，字符 s[i] 就不能单独解码，所以当 s[i] != '0' 时，dp[i] = dp[i - 1] * 1。
说明：为了得到长度为 i + 1 的前缀子串的解码个数，需要先得到长度为 i 的解码个数，再对 s[i] 单独解码，这里分了两步，根据「分步计数原理」，用乘法。这里的 1 表示乘法单位，语义上表示 s[i] 只有 1 种编码。

如果当前字符和它前一个字符，能够解码，即 10 <= int(s[i - 1..i]) <= 26，即 dp[i] += dp[i - 2] * 1；
说明：不同的解码方法，使用「加法」，理论依据是「分类计数的加法原理」，所以这里用 +=。

注意：状态转移方程里出现了下标 i - 2，需要单独处理（如何单独处理，需要耐心调试）。

第 3 步：初始化

如果首字符为 0 ，一定解码不了，可以直接返回 0，非零情况下，dp[0] = 1；
第 4 步：考虑输出

输出是 dp[len - 1]，符合原始问题。

第 5 步：考虑优化空间

这里当前状态值与前面两个状态有关，因此可以使用三个变量滚动计算。但空间资源一般来说不紧张，不是优化的方向，故不考虑。

```C++
class Solution {
public:
    int numDecodings(string s) {
        int len = s.length();
        if (len == 0) {
            return 0;
        }

        // dp[i] 以 s[i] 结尾的前缀子串有多少种解码方法
        // dp[i] = dp[i - 1] * 1 if s[i] != '0'
        // dp[i] += dp[i - 2] * 1 if  10 <= int(s[i - 1..i]) <= 26
        vector<int> dp(len);

        if (s[0] == '0') {
            return 0;
        }
        dp[0] = 1;

        for (int i = 1; i < len; i++) {
            if (s[i] != '0') {
                dp[i] = dp[i - 1];
            }

            int num = 10 * (s[i - 1] - '0') + (s[i] - '0');
            if (num >= 10 && num <= 26) {
                if (i == 1) {
                    dp[i]++;
                } else {
                    dp[i] += dp[i - 2];
                }
            }C++
        }
        return dp[len - 1];
    }
};
```

## 反转链表 II

```C++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        // 相等时不用反转
        if (m == n) return head;
        // 虚拟头节点
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        ListNode *p = dummy;
        // 找到起点
        for (int i = 0; i < m - 1; i ++ )
            p = p->next;
        // 记录当前节点，当前节点的下个节点以及当前节点的下下个节点
        ListNode *a = p, *b = a->next, *c = b->next;
        for (int i = m + 1; i <= n; i ++ )
        {	// 
            ListNode *d = c->next;
            c->next = b;
            b = c;
            c = d;
        }
        a->next->next = c;
        a->next = b;
        return dummy->next;

    }
};
```

## 二叉树的中序遍历

```C++
class Solution {
public:
    vector<int> res;
    vector<int> inorderTraversal(TreeNode* root) {
        // vector<int> res;
        // stack<TreeNode*> stk;
        // TreeNode* cur = root;
        // while(cur || stk.size()) {
        //     while(cur) {
        //         stk.push(cur);
        //         cur= cur->left;
        //     }
        //     cur = stk.top();
        //     stk.pop();
        //     res.push_back(cur->val);
        //     cur = cur->right;
        // }
        // return res;
        
        if (root) {
            inorderTraversal(root->left);
            res.push_back(root->val);
            inorderTraversal(root->right);
        }
        return res;
    }
};
```

不同的二叉搜索树 II 

```C++
class Solution {
    vector<vector<vector<TreeNode*>>> memo;
public:
    vector<TreeNode*> generateTrees( int start, int end) {
        if (start> end) return {nullptr};
        if (!memo[start][end].empty()) return memo[start][end];
        vector<TreeNode*> allTrees;
        // 枚举根节点
        for (int i = start; i<=end; ++i) {
            // 生成左子树
            vector<TreeNode*> lefts = generateTrees(start, i-1);
            // 生成右子树
            vector<TreeNode*> rights = generateTrees(i+1, end);

            for (auto &l : lefts) {
                for (auto &r : rights){
                    TreeNode* cur = new TreeNode(i, l, r);
                    // cur->left = l;
                    // cur->right = r;
                    allTrees.emplace_back(cur);
                }
            }
        }
        return memo[start][end] = allTrees;
    }

    vector<TreeNode*> generateTrees(int n) {
        if (!n) return {};
        memo.resize(n+1, vector<vector<TreeNode*>>(n+1));
        return generateTrees(1, n);
    }
};
```

不同的二叉搜索树 

```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2;i<=n;++i) {
            for (int j = 1;j <= i;++j) {
                dp[i] += dp[j-1]*dp[i-j];
            }
        }
        return dp[n];

    }
};
```

验证二叉搜索树 

```C++
class Solution {
public:
    // long pre = LONG_MIN;
    // bool isValidBST(TreeNode* root) {
    //     if (root == NULL) {
    //         return true;
    //     }

    //     if (!isValidBST(root->left)) {
    //         return false;
    //     }
    //     if (root->val<=pre) {
    //         return false;
    //     }
    //     pre = root->val;
    //     if(!isValidBST(root->right)) {
    //         return false;
    //     }
    //     return true;
    // }
    
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stack;
        long long inorder = (long long)INT_MIN - 1;

        while (!stack.empty() || root != nullptr) {
            while (root != nullptr) {
                stack.push(root);
                root = root -> left;
            }
            root = stack.top();
            stack.pop();
            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root -> val <= inorder) return false;
            inorder = root -> val;
            root = root -> right;
        }
        return true;
    }

};
```

对称二叉树 54. 

二叉树的层序遍历 55. 

二叉树的锯齿形层次遍历 56. 

二叉树的最大深度 57. 

从前序与中序遍历序列构造二叉树 58. 

将有序数组转换为二叉搜索树 59. 

有序链表转换二叉搜索树 60. 

路径总和 II 61. 

二叉树展开为链表 62. 

杨辉三角 63. 

买卖股票的最佳时机 64. 

买卖股票的最佳时机 II 65. 

验证回文串 66. 

只出现一次的数字 67. 

只出现一次的数字 II 68. 

单词拆分 69. 

环形链表 70. 

环形链表 II 71. 

重排链表 72. 

二叉树的前序遍历 73. 

LRU 缓存机制 74. 

排序链表 75. 

逆波兰表达式求值 76. 

乘积最大子数组 77. 

最小栈 78. 

相交链表 79. 

寻找峰值 80. 

多数元素 81. 

Excel 表列序号 82. 

阶乘后的零 83. 

最大数 84. 

重复的 DNA 序列 85. 

旋转数组 86. 

打家劫舍 87. 

二叉树的右视图 88. 

岛屿数量 89. 

快乐数 90. 

移除链表元素 91. 

反转链表 92. 

数组中的第 K 个最大元素 93. 

存在重复元素 94. 

最大正方形 95. 

用队列实现栈 96. 

翻转二叉树 97. 

基本计算器 II 98. 

二叉搜索树中第 K 小的元素 99.

用栈实现队列 100. 

回文链表 101. 

二叉搜索树的最近公共祖先 102. 

二叉树的最近公共祖先 103. 

删除链表中的节点 104. 

除自身以外数组的乘积 105. 

搜索二维矩阵 II 106. 

有效的字母异位词 107. 

各位相加 108. 

缺失数字 109. 

完全平方数 110. 

移动零 111. 

寻找重复数 112. 

Nim 游戏 113. 

最长上升子序列 114. 

超级丑数 115. 

零钱兑换 116. 

3 的幂 117. 

奇偶链表 118. 

递增的三元子序列 119. 

打家劫舍 III 120. 

比特位计数 121. 

反转字符串 122. 

前 K 个高频元素 123. 

两个数组的交集 124. 

两整数之和 125. 

有序矩阵中第 K 小的元素 126. 

字符串解码 127. 

移掉 K 位数字 128. 

根据身高重建队列 129. 

最长回文串 130. 

Fizz Buzz 131. 

字符串相加 132. 

分割等和子集 133. 

找到所有数组中消失的数字 134. 

四数相加 II 135. 

分发饼干 136. 

汉明距离 137. 

数字的补数 138. 

把二叉搜索树转换为累加树 139. 

二叉树的直径 140. 

和为 K 的子数组 141. 

分糖果 142. 

最短无序连续子数组 143. 

合并二叉树 144. 

回文子串 145. 

最大二叉树 146. 

1 比特与 2 比特字符 147. 

最长重复子数组 148. 

自除数 149. 

每日温度 150. 

划分字母区间 151. 

重构字符串 152. 

宝石与石头 153. 

用两个栈实现队列 154. 

斐波那契数列 155. 

数组中重复的数字 156. 

二维数组中的查找 157. 

青蛙跳台阶问题 158. 

旋转数组的最小数字 159. 

替换空格 160. 

从尾到头打印链表 161. 

重建二叉树 162. 

剪绳子 163. 

合并两个排序的链表 164. 

树的子结构 165. 

二叉树的镜像 166. 

对称的二叉树 167. 

调整数组顺序使奇数位于偶数前面 168. 

二进制中 1 的个数 169. 

顺时针打印矩阵 170. 

链表中倒数第 k 个节点 171. 

数值的整数次方 172. 

反转链表 173. 

删除链表的节点 174. 

最小的 k 个数 175. 

包含 min 函数的栈 176. 

连续子数组的最大和 177. 

二叉搜索树与双向链表 178. 

栈的压入、弹出序列 179. 

字符串的排列 180. 

数组中出现次数超过一半的数字 181. 

从上到下打印二叉树 

从上到下打印二叉树 II

从上到下打印二叉树 III 

二叉搜索树的后序遍历序列

第一个只出现一次的字符 

二叉树中和为某一值的路径 

二叉树的深度 

数组中数字出现的次数 

数组中数字出现的次数 II

和为 s 的两个数字 

把数组排成最小的数

和为 s 的连续正数序列 

两个链表的第一个公共节点

礼物的最大价值 

翻转单词顺序 

在排序数组中查找数字 I 

左旋转字符串 

0～n-1 中缺失的数字 

最长不含重复字符的子字符串 

二叉搜索树的第 k 大节点 

丑数 

## 不用加减乘除做加法 

滑动窗口的最大值 

构建乘积数组 

扑克牌中的顺子 

平衡二叉树 

股票的最大利润

求 1+2+…+n 

二叉搜索树的最近公共祖先 

二叉树的最近公共祖先