| 时段 | 星期一                 | 星期二   | 星期三   | 星期四 | 星期五 | 星期六 | 星期天 |
| ---- | ---------------------- | -------- | -------- | ------ | ------ | ------ | ------ |
| 上午 | 每日一题               | 每日一题 | 每日一题 |        |        |        |        |
| 下午 | 投简历，百度，哔哩哔哩 | 划水     | 复习题目 |        |        |        |        |
| 晚上 | 远景智能二面，学习TiDB | 总结题目 | 互娱笔试 |        |        |        |        |

###### 20200810

每日一题：[696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

题目：给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

```C++
class Solution {
public:
    int countBinarySubstrings(string s) {
        int ptr = 0;
        int n = s.size();
        int res = 0;
        int last = 0;
        // 计算01相邻的最小值
        while (ptr < n) {
            char x = s[ptr];
            int count = 0;
            while (ptr < n && s[ptr] == x) {
                count++;
                ptr++;
            }
            res += min(last, count);
            last = count;
        }
        return res;
    }
};
```

###### 20200811

每日一题：

题目：给定一个二维的矩阵，包含 `'X'` 和 `'O'`（**字母 O**）。

找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

解题思路：本题给定的矩阵中有三种元素：

字母 X；
被字母 X 包围的字母 O；
没有被字母 X 包围的字母 O。
本题要求将所有被字母 X 包围的字母 O都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。

注意到题目解释中提到：任何边界上的 O 都不会被填充为 X。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：

对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；
最后我们遍历这个矩阵，对于每一个字母：
如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；
如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。

```C++
class Solution {
public:
    int x[4] = {0,1,0,-1};
    int y[4] = {1,0,-1,0};
    int nr ,nc;
    void solve(vector<vector<char>>& board) {
        nr = board.size();
        if (nr == 0 || board[0].size() == 0) return ;
        nc = board[0].size();

        for (int i = 0; i< nr; ++i) { 
            dfs(board, i, 0);
            dfs(board, i, nc-1);
        }
        for (int i = 0; i < nc; ++i) {
            dfs(board, 0, i);
            dfs(board, nr-1, i);
        }

        for (int i = 0; i< nr; ++i) {
            for (int j = 0; j < nc; ++j) {
                if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }

    }

    void dfs (vector<vector<char>> &board, int i, int j) {
        if (i<0 || i>nr-1 || j<0 || j>nc-1 || board[i][j] != 'O')
            return ;
        
        board[i][j] = 'A';
        for (int k = 0; k < 4; ++k) {
            int nx = i + x[k];
            int ny = j + y[k];
            dfs(board, nx, ny);
        }
    }
};
```

###### 20200812

每日一题：[133. 克隆图](https://leetcode-cn.com/problems/clone-graph/)

题目：给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin)** 图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。

图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。

```C++
class Node {
    public int val;
    public List<Node> neighbors;
}
```

解题：

```C++
class Solution {
public:
    unordered_map<Node*, Node*> visited;
    Node* cloneGraph(Node* node) {
        if (node == nullptr) {
            return node;
        }

        // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回
        if (visited.find(node) != visited.end()) {
            return visited[node];
        }

        // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表
        Node* cloneNode = new Node(node->val);
        // 哈希表存储
        visited[node] = cloneNode;

        // 遍历该节点的邻居并更新克隆节点的邻居列表
        for (auto& neighbor: node->neighbors) {
            cloneNode->neighbors.emplace_back(cloneGraph(neighbor));
        }
        return cloneNode;
    }
};
```

