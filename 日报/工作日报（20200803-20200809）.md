时段 |星期一 | 星期二 | 星期三 | 星期四 | 星期五 | 星期六 | 星期天
---|---|---|---|---|---|---|---|
上午 | 每日一题  | 每日一题
下午 | 招银笔试 | 吃海底捞
晚上 | 划水 | 加油加油

###### 20200803
每日一题：[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)  
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。  
思路：归并排序
```
class Solution {
public:
    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {
        if (l >= r) {
            return 0;
        }
        int mid = (l + r) / 2;
        int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);
        int i = l, j = mid + 1, pos = l;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) {
                tmp[pos] = nums[i];
                ++i;
                inv_count += (j - (mid + 1));
            }
            else {
                tmp[pos] = nums[j];
                ++j;
            }
            ++pos;
        }
        for (int k = i; k <= mid; ++k) {
            tmp[pos++] = nums[k];
            inv_count += (j - (mid + 1));
        }
        for (int k = j; k <= r; ++k) {
            tmp[pos++] = nums[k];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);
        return inv_count;
    }

    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp(n);
        return mergeSort(nums, tmp, 0, n - 1);
    }
};
```

###### 20200804
每日一题：[207. 课程表](https://leetcode-cn.com/problems/course-schedule/)  
题目：你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？  
解题思路：拓扑排序，BFS和DFS
```
class Solution {
public:
    // // BFS，拓扑排序
    // vector<vector<int>> edges;
    // vector<int> ind;
    // bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    //     // 邻接表，入度数组
    //     edges.resize(numCourses);
    //     ind.resize(numCourses);
    //     for (auto x : prerequisites) {
    //         edges[x[1]].push_back(x[0]);
    //         ind[x[0]]++;
    //     }
    //     // 加入入度为零得队列
    //     queue<int> q;
    //     for (int i = 0; i<numCourses; ++i) {
    //         if (ind[i] == 0) {
    //             q.push(i);
    //         }
    //     }
    //     // 记录访问过得节点数
    //     int visited = 0;
    //     while (!q.empty()) {
    //         int node = q.front();
    //         q.pop();
    //         visited++;
    //         // 遍历当前节点得相邻节点，将其入度减一
    //         // 若减完之后为零，则将该节点加入队列
    //         for (int i = 0; i<edges[node].size(); ++i) {
    //             ind[edges[node][i]]--;
    //             if (ind[edges[node][i]] == 0){
    //                 q.push(edges[node][i]);
    //             }
    //         }

    //     }
    //     // 比较访问节点数和总节点数
    //     return visited == numCourses;

    vector<vector<int>> edges;
    vector<int> visited;
    bool flag = true;
    // 每个节点分为三种状态，未被访问，搜寻中，搜寻结束，
    // 当一个节点搜寻的过程中遇到另一个搜索中的节点，即表示有环
    void dfs (int u) {
        visited[u] = 1;
        for (auto x : edges[u]) {
            if (visited[x] == 0) {
                dfs(x);
                if (!flag)
                    return ;
            } else if (visited[x] == 1) {
                flag = false;
                return;
            }
        }
        visited[u] = 2;
    }
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        visited.resize(numCourses);
        // 初始化邻接表
        for (auto x : prerequisites) {
            edges[x[1]].push_back(x[0]);
        }
        // 从每个未被访问的节点深度优先遍历
        for(int i = 0; i< numCourses && flag; ++i) {
            if (visited[i] == 0){
                dfs(i);
            }
        }
        return flag;
    }
};
```